import { ServiceDefinitions } from '../types';
import { CodeGenerator } from './code-generator';
import { CompileConfig, CompilationResult } from './types';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Main compiler for generating tree-shaken containers
 */
export class ContainerCompiler {
  private codeGenerator = new CodeGenerator();

  /**
   * Compile a container for a specific entry point
   */
  public compile<T extends Record<string, any>>(
    serviceDefinitions: ServiceDefinitions<T>,
    config: CompileConfig
  ): CompilationResult {
    const result = this.codeGenerator.compile(serviceDefinitions, config);

    // Write output file if specified
    if (config.outputPath) {
      this.writeOutput(result, config.outputPath);
    }

    return result;
  }

  /**
   * Compile multiple entry points
   */
  public compileMultiple<T extends Record<string, any>>(
    serviceDefinitions: ServiceDefinitions<T>,
    configs: CompileConfig[]
  ): Record<string, CompilationResult> {
    const results: Record<string, CompilationResult> = {};

    for (const config of configs) {
      results[config.entryPoint] = this.compile(serviceDefinitions, config);
    }

    return results;
  }

  /**
   * Write compilation result to file
   */
  private writeOutput(result: CompilationResult, outputPath: string): void {
    const dir = path.dirname(outputPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const content = this.generateFileContent(result);
    fs.writeFileSync(outputPath, content, 'utf8');
  }

  /**
   * Generate complete file content with imports and exports
   */
  private generateFileContent(result: CompilationResult): string {
    const header = `// Auto-generated by Conduit Compiler
// Entry point: ${result.entryPoint}
// Generated on: ${new Date().toISOString()}

`;

    // The CodeGenerator already includes imports in the generated code
    const content = result.generatedCode;

    return `${header}${content}`;
  }

  /**
   * Preview compilation without writing files
   */
  public preview<T extends Record<string, any>>(
    serviceDefinitions: ServiceDefinitions<T>,
    config: CompileConfig
  ): string {
    const result = this.codeGenerator.compile(serviceDefinitions, config);

    return this.generateFileContent(result);
  }
}

/**
 * Convenience function for compiling a single entry point
 */
export function compileContainer<T extends Record<string, any>>(
  serviceDefinitions: ServiceDefinitions<T>,
  entryPoint: keyof T,
  mode: 'factories' | 'container' = 'container'
): CompilationResult {
  const compiler = new ContainerCompiler();
  return compiler.compile(serviceDefinitions, {
    entryPoint: entryPoint as string,
    mode,
  });
}

/**
 * Convenience function for previewing compiled code
 */
export function previewCompilation<T extends Record<string, any>>(
  serviceDefinitions: ServiceDefinitions<T>,
  entryPoint: keyof T,
  mode: 'factories' | 'container' = 'container'
): string {
  const compiler = new ContainerCompiler();
  return compiler.preview(serviceDefinitions, {
    entryPoint: entryPoint as string,
    mode,
  });
}
